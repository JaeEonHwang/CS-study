# 2.5 HTTP
### HTTP 헤더
* 헤더: 바디를 설명하는 정보를 포함해서, 여러가지 정보를 담고 있는 정보 묶음
* 콜론(:)으로 구분되는 key - value 형태로 설정
* HTTP 요청을 할 때 일반헤더, 요청헤더, 응답헤더가 자동으로 생성
---
* 일반헤더
	* 요청한 URL, 요청메서드, Referrer Policy 등을 포함
		* Referrer Policy: 특정 자원을 요청할 때, 해당 자원의 출처를 나타내는 URL의 노출 여부에 대한 보안 정도를 설정
* 요청헤더
	* 클라이언트가 서버에 요청할 때, 클라이언트가 설정하는 헤더
		* 메서드, 클라이언트 OS, 브라우저 정보 등이 담김
* 응답헤더
	* 서버가 클라이언트에게 응답을 보낼 때 설정하는 헤더
	* 서버의 소프트웨어 정보가 담김
	* 일반적으로 해킹을 방지하기 위해 서버 정보를 숨김
## 2.5.1 HTTP/1.0
* 수명이 짦은 연결
* 각 HTTP 요청당 TCP 핸드셰이크가 발생되며, 한 연결당 하나의 요청을 처리하도록 설계되어있음
* 모든 HTTP 요청마다 TCP 연결이 필요하기 때문에 RTT가 늘어나는 문제가 있음
	* RTT(Round Trip Time): 왕복 지연 시간, 신호를 전송하고 해당 신호의 수신확인에 걸린 시간, 어떤 메시지가 두 장치 사이를 왕복하는 데 걸린 시간
	* RTT 증가를 해결하기 위한 방법
		1. 이미지 스플리팅: 많은 이미지가 합쳐 있는 하나의 이미지를 다운받고, background-image의 position을 이용하여 이미지를 표기
		2. 코드 압축: 개행 문자, 빈칸 등을 없애서 코드의 크기를 최소화
		3. 이미지 Base64 인코딩: 이미지 파일을 64진법으로 이루어진 문자열로 인코딩. 이미지에 대한 HTTP 요청을 할 필요는 없지만, 크기가 약 37% 늘어남
## 2.5.2 HTTP/1.1
* HTTP/1.0의 단점을 보완한 프로토콜
### 차이점
1. keep-alive default
	* 한 번 TCP 연결을 한 후에 계속해서 데이터를 받을 수 있음
2. 호스트 헤더
	* HTTP/1.0은 서버가 하나의 호스트만 가진다고 가정하기 때문에 헤더에 호스트를 포함하지 않았음. 그렇기 때문에 HTTP/1.0은 하나의 IP에 하나의 호스트만 가질 수 잇었음
	* 하지만 서버는 여러 개의 호스트를 가질 수 있기 때문에, 이런 유연성을 위해 HTTP/1.1은 헤더에 특정 호스트를 포함할 수 잇게 변경되었으며, 항상 호스트를 포함해서 요청하도록 바뀜
3. 대역폭 최적화
	* HTTP/1.0에서는 특정 파일을 다운로드 받다가 연결이 끊기면 다시 다운로드 받는 것이 불가능 했음.
	* HTTP/1.1에서는 Range:bytes=5000- 라는 헤더를 추가해서 다운로드 재개 요청을 할 수 있게 바뀜
### HTTP/1.1의 문제점
1. HOL Blocking
	* Head Of Line Blocking
	* 네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
2. 무거운 헤더 구조
	* 쿠키 등 많은 메타데이터가 들어있고 압축되지 않아 무거움
## 2.5.3 HTTP/2
* 애플리케이션 계층과 전송 계층 사이에 바이너리 포맷 계층을 추가
* HTTP 1.0은 일반텍스트 메시지를 전송하고 줄바꿈으로 데이터를 나누는 반면, HTTP 2.0은 0과 1로 이루어진 바이너리 데이터로 변경되었고, 더 작은 메시지가 프레임으로 캡슐화 되어서 전송됨.
### 멀티플렉싱
* 단일 TCP연결의 여러 스트림에서 여러 HTTP 요청과 응답을 비동기적으로 보낼 수 있음. 이를 통해 HOL 해결 가능
### 서버 푸시
* 클라이언트 요청 없이 서버가 리소스를 푸시할 수 있음
### 헤더압축
* 똑같은 서버에서 2개의 이미지를 준다고 했을 때, 중복되는 헤더는 제외한채 보내고, 해당 공통 필드로 헤더를 재구성하여 중복되지 않는 헤더값은 허프만 인코딩 압축을 통해 전송
	* 허프만 인코딩: 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용해 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 전체 데이터 표현에 필요한 비트양을 줄이는 알고리즘
### 우선순위
* 서버에서 원하는 순서대로 우선순위를 정해 리소스를 전달할 수 있음
## 2.5.4 HTTPS
* HTTP + TLS = 암호화된 통신
* 암호화: 승인된 당사자만 정보를 이해할 수 있도록 데이터를 '스크램블'하는 방법
	* 스크램블: 각 단어나 문자를 패턴에 따라 암호화하는 것이 아니라 무작위 방식으로 개별 데이터 비트를 섞는 것
	* 복호화하려면 송신자와 수신자가 서로 동의한 '키'가 필요함
	* ciphertext = plaintext + key
* 대칭 암호화
	* 키를 하나만 사용하는 암호화
	* 동일한 키를 이용해 암호화와 해독을 진행
	* DES, AES
* 비대칭 암호화(공개키 암호화)
	* 공개키와 개인키로 데이터를 암호화하고, 공개키를 누구나 사용하게 함
	* 공개키로 암호화된 데이터는 개인키로만 복호화할 수 있음
	* RSA, DH
* 암호화의 필요성
	* 의도된 수신자와 송신자를 제외하고는 통신을 하이재킹하여 읽을 수 없게 함
	* 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장
		* 데이터 무결성: 데이터의 정확성과 일관성
---
### SSL/TSL
* 전송 계층에서 보안을 제공하는 프로토콜
* 진행 순서
	1. Client Hello: 클라이언트가 TLS 버전, 사이퍼슈트, 클라이언트 랜덤값, 임시 DH 매개변수를 서버에 보냄
	2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify: 서버가 클라이언트로부터 받은 옵션들을 확인. 서버와 클라이언트 모두에서 지원하는 가장 높은 TLS 버전을 식별하고 사이퍼슈트 지원 여부를 확인 후 공개키가 포함된 SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보냄. 그리고 클라이언트와 서버 각각 서로 교환한 DH 매개변수를 사용하여 임시 암호 키(세션키)를 생성
	3. Finished: 클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신 시작
---
### DH 매개변수
* Diffie-Hellman 알고리즘: 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘
### 사이퍼 슈트
* 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
* 5가지가 있음. ex) TSL_AES_128_GCM_SHA256
	* AEAD 사이퍼 모드
		* AEAD: 데이터 암호화 알고리즘
		* AES_128_GCM은 128비트의 키를 사용하는 표준 블록 암호화 기술과, 병렬 계산에 용이한 암호화 알고리즘 GCM이 결함된 알고리즘이라는 뜻
	* 해싱 알고리즘
		* 데이터를 추정하기 힘들도록 더 작고 섞여 있는 조각으로 만드는 알고리즘
		* 전자서명을 이용하는데 사용
### 인증서
* 주체(인증서를 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자)와 공개키를 포함하는 데이터 파일
* 보통 CA(인증기관)에서 발급한 SSL 인증서를 기반으로 인증작업을 수행
	* CA(Certificate Authority): 인증서를 발급하는 기업
	* 인증서의 종류
		* 단일 도메인: 단 하나의 도메인에 적용되는 인증서
		* 와일드카드: 도메인의 하위 도메인도 포함하는 인증서
		* 멀티 도메인: 관련되지 않은 다수의 도메인에 적용될 수 있는 인증서
* 주체는 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 활용
* 처음 인증작업을 수행할 때 공개키 활용
## 2.5.5 HTTP/3
* HTTP/2는 여전히 TCP를 사용하기 때문에 초기 연결때 발생하는 RTT로 인한 지연시간이라는 문제점이 있었다. 이를 해결한 버전이 HTTP/3이다.
* QUIC(Quick UDP Internet Connnections)이라는 계층 위에서 실행된다.
* TCP가 아닌 UDP 기반으로 실행된다.
* HTTP/2의 장점이 멀티플렉싱 등의 장점은 유지하면서, 초기연결 설정시 지연시간 감소라는 대표적인 특성도 가지고 있다.
* HTTP/2나 HTTP/3는 HTTPS 위에서 실행되는데, TLS로 암호화통신을 구축할 때의 핸드셰이크를 활용한다. 이를 기반으로 1 - RTT 만에 연결을 성립할 수 있다.
* 열악한 네트워크 환경에서도 낮은 패킷손실률을 보이는 순방향 오류 수정 매커니즘(FEC, Forward Error Correction)을 활용함
	* 순방향 오류 수정 매커니즘: 전송된 패킷이 손실되었을 경우 수신측에서 에러를 검출하고 수정하는 방식
---
## HTTP 상태코드
1. 1XX(정보)
* 서버가 요청을 잘 받았으며, 해당 프로세스를 계속 이어가며 처리
	* 100: 계속 진행
2. 2XX(성공) 
	* 서버가 요청을 잘 받았고, 이를 기반으로 클라이언트에게 성공적으로 데이터를 보낸 것을 의미
		* 200 OK: 요청이 성공적으로 처리됨
		* 201 Created: 요청이 성공적이었으며, 그 결과로 새로운 리소스가 생성
3. 3XX(리디렉션)
* 서버가 클라이언트의 요청에 대해 완료를 위해 추가 작업 조치가 필요
	* 301 Moved Permanently: 요청한 리소스의 URI가 변경되었음. (변경된 새로운 URI를 함께 주어야함)
4. 4XX(클라이언트 오류)
* 클라이언트가 요청한 페이지를 제공할 수 없거나, 클라이언트의 요청이 잘못되어 요청을 처리할 수 없음
	* 400 Bad Request: 서버가 클라이언트 요청을 이해할 수 없음
	* 401 Unauthorized: 클라이언트 인증이 되지 않음
	* 404 Not Found: 요청받은 콘텐츠를 찾을 수 없음
5. 5XX(서버 오류)
* 서버가 클라이언트의 요청을 처리하지 못 함
	* 500 Internal Server Error: 서버에 오류가 있음
	* 502 Bad Gateway: 게이트웨이 또는 프록시서버에 오류
	* 504 Gateway Timeout: 게이트웨이 또는 프록시서버가 정해진 Timeout 시간동안 클라이언트의 요청을 처리하지 못 함
---
## HTTP 메서드
### 1. GET과 POST의 차이
* GET: 데이터를 읽는 것
	* url을 기반으로 데이터 요구
	* 길이 제한(2000자)
	* 성공시 HTTP 상태코드 200 반환
	* 캐싱 가능
	* 요청 파라미터가 브라우저 기록에 남음
	* ASCII문자열만 보낼 수 있음
	* 사용자 이름, 비밀번호 등 민감한 정보를 전달할 때 사용하지 않음
* POST: 데이터를 생성하는 것
	* url이 아닌 HTTP message body를 통해 데이터 전달
	* 길이 제한 없음
	* 성공시 HTTP 상태코드 201 반환
	* 캐싱 불가능
	* 요청 파라미터가 브라우저 기록에 남지 않음
	* 모든 유형의 데이터를 전달 가능
	* 민감한 정보를 전달할 때 사용
### 2. PUT과 PATCH의 차이
* PUT: 업데이트하는 데이터의 전체를 보냄
	* 전체 데이터의 교체
	* 해당 데이터가 없다면 새로 생성
* PATCH: 업데이트하는 데이터의 일부를 보냄
	* 데이터 일부의 교체