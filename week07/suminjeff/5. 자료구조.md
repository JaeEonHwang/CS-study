# 복잡도

### C++의 기본

- C++은 main 함수를 중심으로 돌아감
- 그래서 main 함수 하나를 무조건 만들어야 함
- 이후 컴파일이 시작되면 전역변수 초기화, 라이브러리 import 등의 작업이 일어나며 main함수에 얽혀있는 작업들이 작동됨
- 그러고 main 함수가 0을 리턴하면 프로세스가 종료됨

## 시간 복잡도

- 복잡도는 시간복잡도와 공간복잡도로 나뉘어짐
- 입력크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간
- 빅오표기법(Big - O notation)

### 시간복잡도가 필요한 이유

- 효율적인 코드로 개선하는데 쓰이는 기준
- 비즈니스로직을 구현한다고 했을 때 O(n^2)의 로직을 O(n)으로 고쳤다고 하면서 성능을 향상시켰다고 할 수 있는 것

## 공간복잡도(space complexity)

- 입력크기에 대해 어떠한 알고리즘이 실행되는데 필요한 메모리 공간의 양

### 보통 문제를 풀 때 배열의 범위 등을 잡을 때는 2가지 방법

- 1. 최대범위
- 2. 메모리제한

---

- 1000만까지는 정도는 보통은 된다 하고 잡고 들어가는게 좋음

## 정적배열(Array)

- 연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자인덱스를 기반으로 랜덤접근이 가능하며 중복을 허용

## 동적배열(vector)

- 동적으로 요소를 할당할 수 있는 동적 배열
- 컴파일 시점에 사용해야 할 요소들의 개수를 모른다면 vector를 써야 함
- 연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음이며 숫자인덱스를 기반으로 랜덤접근이
  가능하며 중복을 허용

### 시간복잡도

- 참조 : O(1)
- 탐색 : O(n)
- 맨 끝에 삽입/삭제 : O(1)
- 맨 끝 제외 삽입 / 삭제 : O(n)

## 메모리와 포인터

### 메모리와 주소

- 컴퓨터의 메모리는 메모리 셀의 연속과 같으며 각 셀의 크기는 1바이트이고 고유한 주소가 있음
- 메모리 주소는 16진수로 표기가 되고 C++에서는 &연산자(ampersand, 앰퍼샌드)를 통해 변수의 메모리 주소를 얻을 수 있습

### 포인터

- 자바, 파이썬, 자바스크립트는 개발자가 직접 변수에 메모리를 할당하거나 해제할 수 없고 가비지컬렉터를 통해 메모리관리를 수행
- 하위레벨 언어인 C, C++ 등은 가비지컬렉터가 없으며 대신 개발자가 직접 필요한 메모리를 예약하고 해제할 수 있으며 포인터 또한 지원

#### 포인터의 개념

- 변수의 메모리 주소를 담는 타입이 바로 포인터
- 포인터는 메모리 동적할당, 데이터를 복사하지 않고 함수 매개변수로 사용, 클래스 및 구조체를 연결할 때 사용됨

#### 포인터의 크기

- 포인터의 크기는 OS가 32bit라면 4바이트, 64bit라면 8바이트로 고정되어 있음

## 역참조연산자

- C++에서 \*은 기호는 사용하는 위치에 의해 다양한 용도로 사용됨
- 이항 연산자로 사용하면 곱셈 연산으로, 포인터 타입의 선언, 역참조(dereference)로 메모리를 기반으로 변수의 값에 접근할 때도 사용됨

## array to pointer decay

- 배열의 이름을 주소값으로 쓰는 것 = array to pointer decay
- 배열이 포인터로 부식(decay)되는 현상
- array만 가능

## 연결리스트(linked List)

- 노드로 감싸진 요소를 인접한 메모리 위치가 아닌 독립적으로 저장하며 각 노드는 next 또는 next, prev라는 포인터로 서로 연결된 선형적인 자료구조

```c++
class Node {
public:
    int data;
    Node* next;
    Node(){
        data = 0;
        next = NULL;
    }
    Node(int data){
        this->data = data;
        this->next = NULL;
    }
};

```

### 시간복잡도

- 참조 : O(n)
- 탐색 : O(n)
- 삽입 / 삭제 : O(1)

---

- 연결리스트는 싱글연결리스트, 이중연결리스트, 원형연결리스트 크게 3가지로 설명됨

### 싱글연결리스트

- 싱글연결리스트(Singly Linked List)는 next 포인터밖에 존재하지 않으며 한 방향으로만 데이터가 연결됨

### 이중연결리스트

- 이중연결리스트(Doubly Linked List)는 prev, next 두개의 포인터로 양방향으로 데이터가 연결됨

### 원형연결리스트

- 원형연결리스트(Circular Linked List)는 마지막 노드와 첫번째 노드가 연결되어 원을 형성함

---

### 랜덤접근과 순차적 접근

- 직접 접근이라고 하는 랜덤 접근(random access)은 동일한 시간에 배열과 같은 순차적인 데이터가 있을때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근(sequential access)과는 반대
- vector, Array와 같은 배열은 랜덤접근이 가능해서 n번째 요소에 접근할 때 O(1)이 걸리며 연결리스트, 스택, 큐는 순차적 접근만이 가능해서 n번째 요소에 접근할 때 O(n)이 걸림

---

## 스택(stack)

- 후입선출(LIFO, Last In First Out) 구조를 가진 자료 구조

### 시간복잡도

- n번째 참조 : O(n)
- 가장 앞부분 참조 : O(1)
- 탐색 : O(n)
- 삽입 / 삭제(n번째 제외) : O(1)

---

## 큐(queue)

- 먼저 집어넣은 데이터가 먼저 나오는 성질인 선입선출(FIFO, First In First Out) 구조를 지닌 자료 구조

### 시간복잡도

- n번째 참조 : O(n)
- 가장 앞부분 참조 : O(1)
- 탐색 : O(n)
- 삽입 / 삭제(n번째 제외) : O(1)

---

## 이진트리와 이진탐색트리

- 정이진 트리(full binary tree): 자식 노드가 0 또는 2개인 이진 트리를 의미
- 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리를 의미
  마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 경우 왼쪽부터 채워져 있음
- 변질 이진 트리(degenerate binary tree): 자식 노드가 하나밖에 없는 이진 트리를 의미
- 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리를 의미
- 균형 이진 트리(balanced binary tree): 모든 노드의 왼쪽 하위트리와 오른쪽 하위트리 차이가 1이하인 트리. map, set을 구성하는 레드블랙트리는 균형이진트리 중 하나

### 이진탐색트리(BST, Binary Search Tree)

- 노드의 오른쪽 하위 트리에는 "노드의 값보다 큰 값"이 있는 노드만 포함되고 왼쪽 하위트리에는 "노드의 값보다 작은값"이 들어있는 트리

### 해시테이블(Hash Table)

- 해싱을 통해 한정된 범위의 정수값을 가진 해시로 만들고 해시라는 키에 대응하여 원본 데이터들을 매핑시켜놓은 테이블

#### 해시, 해싱, 해시함수

- 해시 : 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값
- 해싱 : 임의의 데이터를 해시로 바꿔주는 일이며 해시 함수가 이를 담당
- 해시 함수 : 임의의 데이터를 입력으로 받아 일정한 길이의 데이터로 바꿔주는 함수
- 해시함수는 숫자가 아닌 문자열을 기반으로 정수값의 해시를 만들어낼 수도 있음

#### 해시테이블의 충돌문제 해결하기

- 해시테이블의 충돌문제는 “거의 무조건” 일어남
- birthday paradox에 의해 충돌이 발생될 확률은 높음

##### 체이닝

- 충돌시 연결리스트에 할당하고 충돌시 연결리스트를 탐색하는 기법
- 장점: 구현이 간단하며 해시테이블에 많은 데이터를 집어넣을 수 있음
- 단점: 연결리스트기반이라 캐시성능이 좋지 않다. 체인이 길어지면 최악의 경우 O(n)이 될 수 있음

##### 개방 주소법(Open Addressing)

- 충돌시 다른 버켓에 데이터를 삽입하는 기법
- 선형 탐색(Linear Probing)
- 제곱 탐색(Quadratic Probing)
- 이중 해싱(Double Hashing)
