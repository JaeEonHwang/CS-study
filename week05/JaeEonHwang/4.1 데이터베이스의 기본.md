# 4.1 데이터베이스의 기본
* 데이터베이스: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
	* 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 가능
	* 트랜잭션, 데이터 암호화, 백업 및 복구, 실시간 접근과 동시 공유, 사용자에 따른 데이터접근 권한 부여가 가능
* DBMS: 데이터베이스를 제어, 관리하는 통합 시스템
## 4.1.1 엔터티
* 엔터티: 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
### 약한 엔터티와 강한 엔터티
* A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고 B는 강한 엔터티가 됨
## 4.1.2 릴레이션
* 릴레이션: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
* 엔터티에 관한 데이터를 릴레이션 하나에 담아서 관리
* 관계형 데이터베이스에서는 '테이블', NoSQL 데이터베이스에서는 '컬렉션'
### 테이블과 컬렉션
* 관계형 데이터베이스(MySQL): 레코드-테이블-데이터베이스
* NoSQL 데이터베이스(MongoDB): 도큐먼트-컬렉션-데이터베이스
## 4.1.3 속성
* 속성: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
## 4.1.4 도메인
* 도메인: 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합
## 4.1.5 필드와 레코드
### 필드타입
* 엔터티가 데이터베이스에 들어갈 때 엔터티의 속성은 데이터베이스 테이블의 필드로 들어가 필드의 이름, 타입으로 변화되어 들어감
* 이러한 필드를 가진 데이터들이 행 단위로 쌓이게 되는데, 이를 데이터/레코드/튜플이라고 부름
#### 숫자 타입
|타입|용량(바이트)|최솟값(부호 있음)|최솟값(부호 없음)|최댓값(부호 없음)|최댓값(부호 있음)|
|---|---|---|---|---|---|
|TINIYINT|1|-128|0|127|255|
|SMALLINT|2|-32768|0|32767|65535|
|MEDIUMINT|3|-8388608|0|8388607|16777215|
|INT|4|-2147483648|0|2147483647|4294967295|
|BIGINT|8|-2^63|0|2^63-1|2^64-1|
#### 날짜 타입
|타입|용량(바이트)|최솟값|최댓값|
|---|---|---|---|
|DATE|3|1000-01-01|9999-12-31|
|DATETIME|8|1000-01-01 00:00:00|9999-12-31 23:59:59|
|TIMESTAMP|4|1970-01-01 00:00:01|2038-01-19 03:14:07|
#### 문자 타입
##### CHAR
* 0 ~ 255의 값을 가짐
* 레코드를 저장할 때 무조건 선언한 길의 값으로 '고정'해서 저장됨
* 데이터를 검색할 때 유리함
##### VARCHAR
* 가변 길이 문자열
* 0 ~ 65,535 사이의 값을 가짐
* 입력된 데이터에 따라 용량을 가변시켜 저장
* 유동적인 길이를 가진 데이터를 저장할 때 사용
###### VARCHAR 최대길이로 설정할 때 주의할 점
1. MySQL 행의 최대 크기는 65,535 바이트
2. MySQL이 사용하는 문자인코딩방식은 utf8mb4로 4바이트의 이모지와 3바이트의 한글 모두 커버함
3. VARCHAR이 가지는 숫자는 바이트가 아니라 길이제한임
##### TEXT
* 큰 문자열 저장
* 주로 게시판의 본문 저장할 때 사용
###### VARCHAR과 TEXT의 차이
* VARCHAR
	1. 행 내부(메모리)에 데이터를 직접 저장
	2. max size limit를 걸 수 있음
	3. 인덱스를 걸 수 있음
* TEXT
	1. 행 외부(디스크)에 저장되며, 행 내부에는 포인터가 저장됨
	2. max size limit를 걸지 않음. 무조건 최대 65535 길이의 데이터를 저장 가능
	3. 인덱스를 걸 때 크기 제한을 해야 걸 수 있음
##### BLOB
* 이미지, 동영상 등 큰 데이터 저장에 사용
* 하지만 보통은 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장
###### BLOB을 잘 사용하지 않는 이유
1. 성능문제: 데이터베이스에 큰 이진 파일을 저장하면 데이터베이스의 성능이 저하됨. 처리, 관리, 백업 및 복구 시간도 증가
2. 보안 문제: 이미지에 대한 접근을 제어하고 관리하는 것이 복잡해짐
##### ENUM
* 문자열을 열거한 타입
* ENUM('A', 'B', 'C') 형태로 사용
* 단일 선택만 가능
* 리스트에 없는 값이 삽입되면 빈 문자열이 삽입됨
* 각 옵션이 0, 1 등으로 매핑되어 메모리를 적게 사용함
* 최대 65,535개의 옵션 가능
* 공간적 이점이 있지만 애플리케이션 수정에 따라 목록을 수정해야함
##### SET
* 문자열을 열거한 타입
* 다중 선택 가능
* 비트 단위의 연산 가능
* 최대 64개의 옵션
* 공간적 이점이 있지만 애플리케이션 수정에 따라 목록을 수정해야함
## 4.1.6 관계
### 1:1 관계
### 1:N 관계
### N:M 관계
## 4.1.7 키
* 테이블 간의 관계를 명확하게 하고, 테이블 자체의 인덱스를 위해 설정된 장치
* 유일성: 중복되는 값이 없음
* 최소성: 필드를 조합하지 않고 최소 필드만 써서 키를 형성
### 기본키
* PK, Primary Key
* 유일성과 최소성을 만족
#### 자연키
* 중복된 값들을 제외하며 중복되지 않는 것을 '자연스럽게' 뽑다가 나오는 키
* 언젠가 변할 수 있음
#### 인조키
* 인위적으로 유저 id를 부여해서 고유 식별자가 생성됨
* 불변이기 때문에 보통 기본키는 인조키로 설정
### 외래키
* FK, Foreing Key
* 다른 테이블의 기본키를 그대로 참조하는 값
### 후보키
* 기본키가 될 수 있는 후보들
* 유일성과 최소성을 동시에 만족
### 대체키
* 후보키가 두 개 이상일 경우, 어느 하나를 기본키로 지정하고 남은 후보키들
### 슈퍼키
* 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키
### 복합키
* 두 개 이상의 필드를 조합하여 만든 키