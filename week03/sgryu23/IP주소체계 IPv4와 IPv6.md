## IP 주소체계 IPv4와 IPv6
### IPv4
  - 32비트, 2 ** 32개의 주소(41억 9천만) 표현
  - 8비트 단위로 점을 찍어 4개로 구분(8비트의 단위를 옥텟이라고도 함)
    - 예시: 172.16.254.1 이런 식으로 표현된 건 IPv4라고 생각하면 된다.
    - 172처럼 10진수로 표현하는 이유: 편의상 읽기 쉽게 하기 위해서
  - 41억 개로는 부족하기 때문에 NAT, 서브네팅 등 여러 개의 부수적인 기술이 필요하다.

### IPv6
  - 128비트, 2 ** 128개의 주소 표현(많은 주소 처리가 가능하며 NAT, 서브네팅이 필요하지 않음)
  - 16비트씩 8개로 구분
  - 16비트는 16진수로 변환되어 콜론(:)으로 구분하여 표시
  - 앞의 연속되는 0은 생략할 수 있음
  - 앞의 64비트는 네트워크, 뒤의 64비트는 인터페이스 주소

### IPv4와 IPv6의 차이점
#### 1. IPv4는 체크섬이 있지만 IPv6는 체크섬이 없다.
  - IPv6는 헤더의 효율화를 위해 CRC(순환 중복 검사)를 제외한다.
  - 다만 상위 프로토콜(TCP, UDP)에서 이미 체크섬이 있기 때문에 이를 제거할 수 있다.
  - IP 상위 단계인 TCP, UDP에서 이미 checksum을 처리하기 때문에 IP에서 체크섬을 검사할 필요가 없다.

#### 2. IP 헤더 길이
  - IPv4는 헤더가 가변길이, IPv6는 고정길이(40바이트)라서 인터넷 헤더 길이에 대한 정보, 식별, 플래그 등이 삭제되었다.

  #### 참고: CRC(순환 중복 검사)
  - 네트워크 상에서 데이터에 오류가 있는지 확인하기 위한 체크값을 결정하는 방식
  - 데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 된다.
  - 이어서 두 값을 비교하고 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있다.

  #### 라이브러리에서 CRC 구현하기
  1. 설치<br>
  `npm install crc`
  2. 사용<br>
  `import crc32 from 'crc/crc32':`<br>
  `crc32('hello').toString(16):`<br>
  `// '3610a686`<br>

#### 3. TTL(IPv4)은 HOP limit(IPv6)으로 대체되었다.
  ##### TTL이란?
  - IPv4에서 TTL 필드는 패킷이 네트워크에서 무한순환하지 않도록 하는 변수
  - 패킷이 네트워크에서 라우터를 거칠 때마다 TTL 값이 1씩 감소한다.
  - 값이 0이 되면 패킷이 폐기된다.

#### Q) IPv4와 IPv6 누가 더 빠를까?
  - 보통 IPv6가 속도가 더 빠르지만 IPv6가 사용하는 더 큰 패킷 크기로 인해 일부 사용 사례에서는 속도가 느려질 수 있다.