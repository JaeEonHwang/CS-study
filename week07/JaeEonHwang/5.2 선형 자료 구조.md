# 5.2 선형 자료 구조
* 요소가 일렬로 나열되어 있는 자료 구조
## 5.2.1 연결 리스트
* 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조
	* 싱글 연결 리스트: next 포인터만 가짐
	* 이중 연결 리스트: prev, next 포인터를 가짐
	* 원형 싱글 연결 리스트: 마지막 노드의 next 포인터가 헤드 노드를 가리킴 
	* 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가리키고, 헤드 노드의 prev 포인터가 마지막 노드를 가리킴
### 메모리와 주소
* 컴퓨터의 메모리는 메모리 셀의 연속
	* 각 셀의 크기는 1바이트이고 고유한 주소가 있음
* 메모리 주소: 변수가 사용하는 메모리 셀 중 첫번째 메모리 셀의 주소
	* 16진법으로 표기
### 포인터
* 포인터: 메모리 주소를 담는 타입
	* 메모리 동적할당, 데이터를 복사하지 않고 함수 매개변수로 사용, 클래스 및 구조체를 연결할 때 사용
	* OS가 32bit이면 4바이트, 64bit이면 8바이트로 고정
### 역참조연산자
### array to pointer decay
* 배열의 이름을 포인터에 할당하면서 정적배열의 크기 정보가 사라지고, 첫번째 요소의 주소가 바인딩되는 형상
## 5.2.2 Array(정적 배열)
* 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
### 랜덤 접근과 순차적 접근
* 랜덤 접근: 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
* 배열은 랜덤 접근이 가능하고, 연결 리스트는 순차적 접근만 가능하다. = 배열은 탐색이 빠르고 연결 리스트는 느리다.
* 배열은 모든 데이터를 이동시켜야 데이터 추가/삭제가 가능하지만, 연결 리스트는 선 연결만 바꾸면 데이터 추가/삭제가 가능하다. = 배열은 추가/삭제가 느리고 연결 리스트는 빠르다.
## 5.2.3 벡터(동적 배열)
* 동적으로 요소를 할당할 수 있는 동적 배열
* 중복 허용, 순서 있음, 랜덤 접근 가능
* 탐색, 맨 뒤/맨 앞의 요소를 삭제/삽입할 때: O(1)
* 그 외의 요소를 삭제/삽입: O(n)
* 뒤에서부터 삽입하는 push_back()는 amortized 복잡도(=O(1))
## 5.2.4 스택
* 가장 마지막으로 들어간 데이터가 가장 먼저 나오는 자료 구조
## 5.2.5 큐
* 먼저 집어넣은 데이터가 먼저 나오는 자료 구조