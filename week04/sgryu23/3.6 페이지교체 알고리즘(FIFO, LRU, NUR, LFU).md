## 페이지교체 알고리즘: FIFO, LRU, NUR, LFU
  * 스와핑이 일어날 때 페이지교체 알고리즘(page replacement algorithm)에 의해 페이지가 교체되게 됨

### 오프라인 알고리즘
  * 오프라인 알고리즘은 가장 좋은 알고리즘이라고 일컬음
  * 가장 먼 미래에 참조되는 페이지와 현재의 페이지를 바꾸는 알고리즘(LFD, Longest Forward Distance)
    * 예를 들어 0, 1, 2, 3, 4, 2 이렇게 들어온다고 가정하면 가장 미래에 참조되는 2와 스와핑 되는 것
  * 그러나 미래에 사용되는 프로세스를 우리는 알지 못함
  * 즉, 사용할 수 없는 알고리즘이지만 다른 알고리즘과의 성능 비교에 대한 상한선(upper bound)을 제공함

### FIFO
  * 먼저 들어온 페이지를 먼저 빼낸다.

### LRU(Latest Recently Used)
  * 최근에 사용되지 않은 페이지를 바꾸는 방법
  * 참조가 오래된 페이지를 바꿈
  * 이를 위해 각 페이지마다 최근 사용한 횟수를 나타내는 자료구조를 따로 만들어야 할 수도 있음
  * 예를 들어 7 0 1 2 0 3 0 4로 페이지 요청이 들어온다고 가정하고 4개의 페이지만 담는다고 가정하면 다음과 같이 됨
  7012 -> 7012(0은 히트가 됨) -> 3012(7이 가장 오래 되었으니까) -> 3012(0은 히트됨) -> 3042

### NUR(Not Used Recently)
  * LRU에서 발전한 알고리즘이자 NUR(Not Used Recently) 또는 Not Recently Used라고도 불리는 알고리즘
  * 일명 clock 알고리즘이라고 하며 먼저 0과 1을 가진 비트를 둠
  * 1은 최근에 참조되었고 0은 참조되지 않음을 의미
  * 만약 한 바퀴 도는 동안 사용되지 않으면 0이 됨
  * 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 페이지를 교체하고 해당 부분을 1로 바꾸는 알고리즘(반대로 1인 부분을 한 바퀴 돌 동안 참고가 되지 않으면 0으로 바꿈)

### LFU(Latest Frequently Used)
  * LFU 알고리즘은 가장 참조 횟수가 적은 페이지를 교체하는 알고리즘
  * 예를 들어 0, 1, 2, 0, 0, 1, 2, 3 이렇게 들어오고 3개의 페이지밖에 없다고 하면 다음과 같이 교체됨
    | 0 | 0 | 0 | 0 | 0 | 0 |
    |---|---|---|---|---|---|
    | 1 | 1 | 1 | 1 | 1 | 3 |
    | 2 | 2 | 2 | 2 | 2 | 2 |
  * 0, 1, 2의 참조 횟수는 각각 3회, 2회, 2회
  * 가장 참조횟수가 적은 1과 스와핑(2는 어디감?)