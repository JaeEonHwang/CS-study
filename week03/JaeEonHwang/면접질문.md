# 1. REST API란 무엇인가요?
* RESTful한 API를 말하며, 일련의 특징과 규칙을 지키는 API를 말한다.
* 2000년에 Roy Thomas Fielding의 논문에 처음으로 등장한 개념
## 주요 특징
### 1. Uniform-Interface
* 자원들은 각각의 독립적인 인터페이스를 가지며, 각각의 자원들이 url 자원식별, 표현을 통한 자원조작, Self-descriptive messages, HATEOAS 구조를 가지는 것
	* url 자원식별: 자원은 url로 식별되어야 함
	* 표현을 통한 자원조작: url과 HTTP 메서드를 통해 작업을 설명할 수 있는 정보가 담겨야 함
	* Self-descriptive messages: HTTP 헤더에 타입을 명시하고, 각 메시지들은 MIME types에 맞춰 표현되어야 함.(만약 json을 반환한다면 application/json으로 명시해주어야 한다.)
	* HATEOAS 구조: 하이퍼링크에 따라 다른 페이지를 보여줘야 하며, 어떤 URL에서 원했는지 명시해주어야 한다.
### 2. Stateless
* REST API를 제공해주는 서버는 세션을 해당 서버 쪽에 유지하지 않음
### 3. Cacheable
### 4. Client-Server 구조
* 클라이언트와 서버가 서로 독립적인 구조를 가져야 함
### 5. Layered System
* 계층구조로 나눠져 있는 아키텍처
## REST API URI 규칙
1. 동작은 HTTP 메서드로만 해야 하고 url에 해당 내용이 들어가면 안 됨
2. jpg, png 등 확장자는 표시되면 안 됨
3. 동사가 아닌 명사로 표기해야함
4. 계층적인 내용을 담아야 함(ex. /집/아파트/전세)
5. 소문자만을 사용하며, 바를 사용해야할 경우 언더바대신 -를 사용
6. HTTP 응답 상태코드를 적재적소에 활용
# 2. 브라우저 렌더링이란 무엇인가요?
* 브라우저는 브라우저엔진, 렌더링엔진, 네트워크통신부, 자바스크립트 해석기, UI배개엔드, 자료저장소로 이루어져 있음. 이 중 렌더링엔진이 브라우저 렌더링을 관장함
### 1. DOM 트리와 CSSOM트리 구축
* DOM 트리: html 페이지에 있는 요소(div, span 등)들을 하나의 노드로 설정하여 트리 형태로 저장
* CSSOM 트리: 정해진 스타일 규칙을 기반으로 트리 생성, DOM 트리 구축과 동시에 일어남
### 2. 렌더트리와 렌더레이어 생성
* DOM트리와 CSSOM트리를 합쳐 렌더객체 생성
* 렌더객체들을 모아 렌더트리 생성
* 렌더트리에 최적화를 거쳐 렌더레이어 완성
* 렌더레이어가 완성될 때 GPU에서 처리하는 부분은 그래픽 레이어로 분리
### 3. 렌더레이어를 대상으로 레이아웃 설정
### 4. 렌더레이어 칠하기
* 점을 찍듯 픽셀마다 칠함(레스터화)
### 5. 레이어 합치기 및 표기
* 각각의 레이어로부터 비트맵이 생성되고 GPU에 텍스처로 업로드
* 텍스처들이 서로 합쳐저 하나의 이미지로 렌더링되며 화면으로 출력
### 렌더트리와 DOM트리는 1:1 대응일까?
DOM트리가 렌더크리가 되는 과저에서 display:none으로 사라지는 노드들이 있을 수 있기 때문에 1:1 대응이 아니다.
# www.naver.com을 쳤을 때 생기는 과정, 그리고 DNS까지 설명해주세요
* 리다이렉트, 캐싱, DNS, IP 라우팅 & ARP, QUIC 연결 구축을 거쳐 요청, 응답이 일어나는 TTFB(Time To First Byte)가 시작되고, 이 후 콘텐츠가 다운되면 브라우저렌더링을 거쳐 화면이 나타나게 된다.
### 리다이렉트
* 리다이렉트가 있다면 진행하고, 없다면 해당 요청이 진행된다.
### 캐싱
* 요청된 값의 결과값을 저장하고, 그 값을 다시 요청하면 제공하는 기술
* 해당 요청이 캐싱 가능한지 파악
* 캐시가 존재한다면 캐시값을 반환하며, 캐싱되지 않은 새로운 요청이라면 다음 단계로 넘어감
* 캐시가 없다면 같은 요청이 반복적으로 생길 수 있음
1. 브라우저 캐시
	* 쿠키, 로컬스토리지 등을 포함
	* 개인 캐시라고도 함
	* 브라우저가 HTTP를 통해 다운로드 되는 모든 문서를 보유하는 것
2. 공유 캐시
	* 클라이언트와 서버 사이에 존재
	* 사용자간에 공융할 수 있는 응답 저장
	* ex) 프록시서버
### DNS
* FQDN을 IP로 바꿔주는 시스템
	* FQDN: 호스트와 도메인이 합쳐진 완전한 도메인 이름
### IP 라우팅
* IP를 기반으로 IP 라우팅이 일어나고 ARP 과정을 거쳐 실제 서버를 찾음
### TCP 연결 구축
* 브라우저가 TCP 3way 핸드셰이크 및 SSL 연결 등을 통해 연결을 설정
	* HTTP/3 이후에는 QUIC를 통해 연결하고 데이터를 주고 받음
### 콘텐츠 다운로드
* 사용자가 요청한 콘텐츠를 서버로부터 다운로드 받음
### 브라우저 렌더링
* 받은 데이터를 브라우저 엔진이 브라우저 렌더링 과정을 거쳐 화면을 만듦
# 이더넷 프레임은 무엇이며 구조가 어떻게 되나요?
* 데이터 링크 계층의 데이터 단위
* 이더넷 프레임을 기반으로 데이터가 전달됨
1. Preamble: 7바이트, 이더넷 프레임이 시작임을 알려준다.
2. SFD: 1바이트, 다음 필드부터 주소필드가 시작됨을 알려줌
3. Destination Address: 6바이트, 목적지 주소
4. Source Address: 6바이트, 시작지 주소
5. EtherType: 2바이트, 데이터링크계층 위의 IP 프로토콜을 정의(IPv4, IPv6)
6. Payload: 가변바이트, 이진데이터로 구성, 전달하는 데이터가 담김
7. FCS: 4바이트, 수신측의 에러검출을 위해 삽입하는 필드. CRC 에러검출 기법에 의해 생성된 비트배열이 담김. 비트배열을 기반으로 수신된 데이터가 손상되었는지 확인하고, 에러가 있을 시에는 해당 프레임을 폐기하고 송신측에 재전송을 요구
# CORS란 무엇인가요?
* 오리진: 프로토콜 + 호스트(호스트이름 + 포트), https://www.naver.com:443
* SOP: 브라우저 상에서 같은 오리진끼리만 요청을 허가하는 보안정책
* CORS: HTTP 헤더를 기반으로 브라우저가 다른 오리진에 대한 리소스로드를 허용해주는 매커니즘
* 필수적인 메서드 타입, 헤더가 포함되어 있지 않으면 preflight request를 보내게 됨
* preflight request 과정
	1. OPTIONS 메서드로 해당 서버에 원래의 요청을 보내기 전 요청을 보냄
	2. 요청을 받은 서버는 Access-Control-* 헤더로 응답
	3. Access-Control-* 헤더에 요청한 오리진이 존재하지 않는다면 CORS 에러 발생
* 필수 메서드타입, 헤더
	1. 메서드 타입
		* GET
		* HEAD
		* POST
	2. 헤더
		* Accept
		* Accept-Language
		* Content-Language
		* Content-Type
			* application/x-www-form-urlencoded
			* multipart/form-data
			* text/plain
		* Range