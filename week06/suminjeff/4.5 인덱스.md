## 인덱스

### 인덱스의 필요성

- 데이터를 빠르게 찾기 위함

### B-트리

- 인덱스는 보통 B-트리라는 자료구조로 이루어져 있음
- 루트, 리프, 브랜치 노드로 나뉨

### 인덱스가 효율적인 이유와 대수확장성

- 대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미
- 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

### 인덱스 만드는 법

#### MySQL

- 클러스터형 인덱스
  - 테이블당 하나 설정
  - primary key 옵션으로 키본키로 만들면 클러스터형 인덱스를 생성할 수 있음
  - 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있음
- 세컨더리 인덱스
  - create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있음
  - 하나만 만들거면 클러스터형 인덱스가 성능이 좋음

#### 몽고DB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성됨
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리를 같이 쓰는 복합 인덱스를 설정할 수 있음

## 인덱스 최적화 기법

### 인덱스는 비용이다

- 인덱스는 두 번 탐색하도록 강요함 (읽기 비용)
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함
- B-트리의 높이를 균형 있게 조절하는 비용도 들고 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 듬

### 항상 테스팅하라

- 인덱스 최적화 기법은 서비스 특징에 따라 달라짐
- explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함

### 복합 인덱스는 같음, 정렬, 다중값, 카디널리티 순

- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라짐
- 같음, 정렬, 다중 값, 카디널리티(유니크한 값의 정도) 순으로 생성해야 함
