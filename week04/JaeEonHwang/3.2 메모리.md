# 3.2 메모리
## 3.2.1 메모리 계층
1. 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 작음
2. 캐시: 휘발성, 속도 빠름, 기억 용량 적음
3. 주기억장치: RAM, 휘발성, 속도 보통, 기억 용량 보통
4. 보조기억장치: HDD, SSD, 휘발성, 속도 낮음, 기억 용량 많음
* 계층의 존재 이유
	* 더 빠른 접근과 처리속도 증가
	* 비용의 효율성
	* 자원의 효율적 사용
### 캐시
* 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
* 같은 것을 다시 계산하는 시간을 절약
#### 지역성의 원리
* 지역성: 자주 사용하는 데이터에 대한 근거
##### 시간 지역성
* 최근 사용한 데이터에 다시 접근하려는 특성
##### 공간 지역성
* 최근 접근한 데이터를 이루고 있는 공간이나 가까운 공간에 접근하는 특정
#### 캐시히트와 캐시미스
##### 캐시히트
* 캐시에서 원하는 데이터를 찾는 데 성공한 것
* 제어장치에서 데이터를 가져옴
* CPU 내부 버스를 기반으로 작동하기 때문에 빠름
##### 캐시미스
* 원하는 데이터가 캐시에 없어서 메모리에서 데이터를 찾아오는 것
* 시스템 버스를 기반으로 작동하기 때문에 느림
##### 캐시매핑
* 캐시가 히트되기 위해 매핑하는 방법
1. 직접 매핑: 순서를 일치시켜서 매핑, 처리가 빠르지만 충돌 발생이 잦음
2. 연관 매핑: 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑, 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느림
3. 직접 연관 매핑: 직접 매핑과 연관 매핑을 합쳐 놓은 것. 순서는 일치시키지만 집합을 둬서 저장. 블록화되어 있기 때문에 좀 더 효율적
#### 웹 브라우저의 캐시
* 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아니덴티티나 중복 요청 방지를 위해 쓰임
##### 쿠키
* 만료기한이 있는 키-값 저장소
* 다른 도메인에서 요청했을 때 자동 전송
* 4KB까지 저장
* 만료기한 설정 가능, 보통 서버에서 정함
* document.cookie로 쿠키를 볼 수 없도록 httponly 옵션을 거는 것이 중요
##### 로컬 스토리지
* 만료기한이 없는 키-값 저장소
* 10MB까지 저장
* 브라우저를 닫아도 유지
* 도메인 단위로 저장, 생성
* 클라이언트에서만 수정 가능
##### 세션 스토리지
* 만료기한이 없는 키-값 저장소
* 탭 단위로 생성, 탭을 닫을 때 데이터 삭제
* 5MB까지 저장
* 클라이언트에서만 수정 가능
## 3.2.2 메모리 관리
### 가상메모리
* 메모리 관리 기법의 하나
* 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것
* 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어있는 '페이지 테이블'에서 관리됨
* 속도 향상을 위해 TLB 사용
	* TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층
* 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환
#### 스와핑
* 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 없는 데이터에 접근할 경우 페이지 폴트가 생김. 
* 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것.
#### 페이지 폴트
* 프로세스의 주소 공간에는 존재하지만, RAM에는 없는 데이터에 접근했을 경우 발생
##### 페이지 폴트와 스와핑 과정
1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알림
2. 운영체제는 CPU의 동작을 잠시 멈춤
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾음. 물리 메모리에도 없다면 스와핑 발동
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화함
5. 중단되었던 CPU 다시 시작
### 스레싱
* 메모리의 페이지 폴트율이 높은 것
* 컴퓨터의 심각한 성능 저하를 초래
* 메로리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생
* 해결방법
	* 메모리 늘리기
	* HDD에서 SSD로 바꾸기
	* 작업세트
		* 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것
		* 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있음
	* PFF
		* Page Fault Frequency
		* 상한선과 하한선을 만들어서 페이지 폴트 빈도를 조절하는 방법
		* 상한선에 도달하면 페이지를 늘리고, 하한서네 도달하면 페이지를 줄임
### 메모리 할당
* 시작 메모리 위치 메모리의 할등 크기를 기반으로 메모리에 프로그램을 할당
#### 연속 할당
* 메모리에 연속적으로 공간을 할당하는 것
##### 고정 분할 방식
* 메모리를 미리 나누어 관리
* 융통성이 없음
* 내부 단편화 발생: 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
##### 가변 분할 방식
* 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
* 외부 단편화 발생: 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상
1. 최초적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
2. 최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당
3. 최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
#### 불연속 할당
* 메모리를 불연속적으로 할당
##### 페이징
* 동일한 크기의 페이지 단위로 나누어, 메모리의 서로 다른 위치에 프로세스를 할당
* 홀의 크기가 균일해지지만, 주소 변환이 복잡
* 현대 운영체제에서 사용
##### 세그멘테이션
* 페이지 단위가 아닌, 위미 단위인 세그먼트로 나누는 방식
* 프로세스를 코드, 데이터, 함수 등의 단위로 나눌 수 있음
* 공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않음
##### 페이지드 세그멘테이션
* 공유나 보안은 세그먼트 단위로, 물리적 메모리는 페이지로 나눔
### 페이지 교체 알고리즘
* 스와핑이 일어나는 알고리즘
#### 오프라인 알고리즘
* 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
* 가장 좋은 방법이지만 실현 불가능한 방법
* 다른 알고리즘과의 성금 비교에 대한 기준 제공
#### FIFO
* 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
#### LRU
* 참조가 가장 오래된 페이지를 바꿈
* 오래된 것을 파악하기 위해 페이지마다 계수기, 스택을 두어야 하는 문제점
* 해시 테이블과 이중 연결 리스트 자료구조로 구현
	* 해시 테이블: 이중 연결 리스트에서 빠르게 찾을 때
	* 이중 연결 리스트: 한정된 메모리를 나타냄
#### NUR
* 0과 1을 가진 비트를 둠
	* 0: 최근 참조
	* 1: 참조되지 않음
* 시계 방향으로 돌면서 0을 찾는 순간 해당 프로세스를 교체하고 해당 부분을 1로 바꿈
#### LFU
* 참조 횟수가 가장 적은 페이지를 교체